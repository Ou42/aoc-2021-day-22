union of first 10 cuboids from AoC 2021 Day 22
blender:    vol = 547647.0766 mm^3
my solveA:  vol = 547647
my solveB WIP:
            vol = 552507
  where:
    > vol $ map snd ndg
    > d <- readFile i3          -- i3.txt = first 10 power steps (aka cuboids)
    > as = allSteps d           -- [('+',[(-32,18),(-49,-2),(-43,3)]), ... ]
    > ndg = newDiffGrps as      
                                -- newDiffGrps recursively splits cuboids
                                -- ... taking the difference of 2 at a time
                                -- [('+',[(-22,27),(-46,-2),(-12,37)]), ... ]

-----
552507 - 547647 = 4860
-----

> map (vol . (:[]) . snd) ndg
[112500,24192,3024,3384,46436,408,13464,1848,1156,1700,49500,6992,1134,3078,1650,9126,3575,13662,6003,11286,6050,11880,285,5244,342,4968,990,2340,1656,2640,315,68,57,2052,10127,3380,9568,15,1120,456,1519,520,637,108,676,588,3072,2688,1664,384,1456,420,768,2448,576,1872,416,2340,312,360,144,720,1056,3936,1872,86,318,10176,96,288,160,2720,5270,4794,550,3689,987,9400,105750]

-----

> solveA $ unlines $ take 2 $ lines d
231540
> vol $ map snd $ newDiffGrps $ take 2 as
231540

> fa i = solveA $ unlines $ take i $ lines d
> fb i = vol $ map snd $ newDiffGrps $ take i as

> map (\i -> fa i == fb i) [1..10]
[True,True,True,True,True,True,False,False,False,False]

> fa 6 == fb 6 -- True      > fa 6 -- 429183    > fa 7 -- 477877
> fa 7 == fb 7 -- False     > fb 6 -- 429183    > fb 7 -- 480397

> fb 7 - fa 7  -- 2520

==============================

> d <- readFile i3
> as = allSteps d
> sb i = newDiffGrps $ take i as
> sb6 = sb 6

> sb6
[('+',[(-15,21),(0,9),(-35,-28)]), ... ]

> sb6 !! 0
('+',[(-15,21),(0,9),(-35,-28)])
> head ((init (tails sb6)) !! 0)
('+',[(-15,21),(0,9),(-35,-28)])

*Main Data.List> zipWith (==) sb6 $ map (head) $ init $ tails sb6
[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True]

*Main Data.List> map (\(hPwrStep:tPwrSteps) -> iFree hPwrStep tPwrSteps) $ init $ tails sb6
[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True]

> cu7 = last $ take 7 as
> sb7temp = sb6 ++ [cu7]

> iF7 = map (\(hPwrStep:tPwrSteps) -> iFree hPwrStep tPwrSteps) $ init $ tails sb7temp
*Main Data.List> iF7
[False,False,False,False,True,True,True,False,True,True,True,False,True,False,True,True,True,True,True,True,True,True,True,True,True,True,True,False,True,False,False,False,True,True,True,True,False,True]

======

2 BIG refactors of newDiffGrps! OK OK one tiny one HUGE refactor
tiny refactor:
  . got rid of nested helper funcs
  . got rid of the nested where
  . got rid of sending in tail & head as args
  . got rid of storing psDone. jsut prepend it to the list and recurse!
  . got rid of the (h:t) destructuring, but then put it back in later
HUGE refactor
  . got rid of nested go function
  . reimplemented (h:t) destructuring
  . pushed the (h:t) to the function invocation(?) w/ the '@' feature
  
*** AND *** I *** BROKE IT FURTHER!!! ***

| FIXED "breakaged" introduced during refactoring:
|   else newDiffGrps (diff psA psRest) ++ psRest
| should be:
|   else newDiffGrps (diff psA psRest ++ psRest)
+----------------------------------------------------------


> d <- readFile i3
> as = allSteps d
> sa i = unlines $ take i $ lines d
> sb i = newDiffGrps $ take i as
> vb i = vol $ map snd $ sb i

> map (solveA . sa) [1..10]
> map vb [1..10]

            1       2       3       4       5       6      
solveA      115056  231540  321769  376667  402927  429183 
"slvB" (vb) 115056  231540  321769  376667  402927  429183
           
solvers diverge on Power Step 7 ...
            7       8       9       10 
solveA      477877  505133  529947  547647
"slvB" (vb) 480397  507653  532467  552507

> map (\(h:t) -> iFree h t) $ (init $ tails sb6)
[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True]


=====

> ld = lines d
> sa2 cu0 cu1 = solveA $ unlines $ [ld !! cu0] ++ [ld !! cu1]
> sb2 cu0 cu1 = vol $ map snd $ newDiffGrps intersects $ [(allSteps d) !! cu0] ++ [(allSteps d) !! cu1]

> pairs = [ (a,b) | a <-[0..9], b <-[0..9], a /= b]
> map (\(cuA,cuB) -> (sa2 cuA cuB) == (sb2 cuA cuB)) pairs

> map (\(cuA,cuB) -> (sa2 cuA cuB) == (sb2 cuA cuB)) pairs
[True,True,True,True,True,True,True,True,True,True,True,True,True,True,False,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,False,True,True,True,True,True,True,True,True,True,True,True,True,True,True,False,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,False,True,True,True,True,True,True,True,False,True]

> filter (\(cuA,cuB) -> (sa2 cuA cuB) /= (sb2 cuA cuB)) pairs
[(1,6),(4,3),(6,0),(8,9),(9,7)]

> sa2 1 6   214704
> sb2 1 6   235494

> newDiffGrps intersects $ [(allSteps d) !! 1] ++ [(allSteps d) !! 6]
[('+',[(-15,35),(-31,16),(-9,43)]),('+',[(3,49),(-29,15),(-45,4)])]

-- THE BUG IS: cubA's Y's are both OUTSIDE/SURROUNDING cubB's Y's

===> and, FIXED:

vol $ map snd $ newDiffGrps intersects3 $ allSteps d
547647

This EQUALS solveA's result!