# Filling the Remnant

Here I'll explore how to accurately fill the remnant with the correct non-intersecting cuboids so that the volume of the combined cuboids can be calculated.

## Positioning the Effort

Here's the **solver**'s top-level function:

```haskell
scottSolver inputText =
  sum $ map volume $ generateRemnant $ parseInputText inputText
```

where

* `sum` adds together the volumes for all the non-intersecting cuboids in the `Remnant`.
* `volume` calculates the volume for each of the `Remnant` cuboids.
* `generateRemnant` processes the cuboids specified in each `RebootStep` generated by...
* `parseInputText` generates the `RebootStep`'s specified by the exercise's `inputText`.
* `inputText` is read from the text file supplied by the exercise. It consists of the "reboot instructions" for the reactors in the exercise's submarine.

It's the middle step, **`generateRemnant`** that is the hard part; the reduction of the cuboids specified in the `RebootStep` list is a non-trivial puzzle to figure out.

## Top-level Approach

The top-level approach is to modify the `rebootStep`s cuboids to identify how they overlap with each other, and then derive a new collection of non-intersecting cuboids having the same collective volume as the merging and reduction of the original `rebootStep` cuboids.

Later in this document we'll discuss the algoritms for identifying the new set of non-intersecting algorithms resulting from combining two cuboids.  But before we do that, I want to figure out the broader challenge of how to recursivly make sure that cuboids are continually broken apart until all cuboids are completely non-intesecting with each other.

### Preconditions

1. Ultimately, the algorithm has two operations, **augmentation** and **reduction**.  The two have different combinational effects, and so will be approached separately.
1. There are the following entities:
    * The list of initial cuboids, each with their associated actions, **augment** or **reduce**.
    * The target **remant** is empty.

### Approach

Here goes:

For the first cuboid, since there are no cuboids in the **remnant**, place the first cuboid in it.  This is the first non-intersecting cuboid in the **remnant** since there are no other cubois in it.  Now that we have all of the non-intersecting cuboids for the first **rebootstep** cuboid, consider this **renmant** to be the *input* **remnant** in the following discussion.

---

Repeat the following process for the remaining cuboids in the **reboot steps** list:

Identify the cuboid in the current **rebootstep**.  This is always indentified as the *target* cuboid, in that the cuboids in the **remnant** will be repeatedly applied to the target to fracture itself into sufficiently small pieces that the subset of the remaiing pieces will be dumped into a new *output* **remant**.

Hence:

**Augment** each cuboid in the *source* **remnant** to each cuboid in the *target* **remnant**.  If there are not yet any cuboids in the *target* **remnant**, then do nothing and continue.

If the pair intersect, then do the following:

1. Indentify the *intersection* cuboid and the remaining *non-intersection* cuboids.
1. Add the *non-intersection* cuboids to the *target* **remnant**.
1. Discard the *non-intersection* cuboid since a previous cuboid in the *source* **remnant** already has its volume covered.

At the end of this process for each **rebootStep** cuboid:

1. The *target* remnant will have all of the non-intersecting cuboids needed to represent this **rebootStep** cuboid and the previous **rebootStep** cuboids.
1. Prepend the *target* **remnant** to the *source* **remnant**.[^1]
1. Reset the *target* **remant** to empty.
1. Now we are ready for the next **rebootStep** cuboid; hence repeat this step.

---

** TODO

1. Implement how **reduce** works (should be much easier).

** Footnotes

[^1]: The order is important because concatenating a long list to the end of a short list is faster than vice-versa.
