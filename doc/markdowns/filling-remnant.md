# Filling the Remnant

Here I'll explore how to accurately fill the remnant with the correct non-intersecting cuboids so that the volume of the combined cuboids can be calculated.

## Positioning the Effort

Here's the **solver**'s top-level function:

```haskell
scottSolver inputText =
  sum $ map volume $ generateRemnant $ parseInputText inputText
```

where

* `sum` adds together the volumes for all the non-intersecting cuboids in the `Remnant`.
* `volume` calculates the volume for each of the `Remnant` cuboids.
* `generateRemnant` processes the cuboids specified in each `RebootStep` generated by...
* `parseInputText` generates the `RebootStep`'s specified by the exercise's `inputText`.
* `inputText` is read from the text file supplied by the exercise. It consists of the "reboot instructions" for the reactors in the exercise's submarine.

It's the middle step, **`generateRemnant`** that is the hard part; the reduction of the cuboids specified in the `RebootStep` list is a non-trivial puzzle to figure out.

# Top-level Approach

The top-level approach is to modify the `rebootStep`s cuboids to identify how they overlap with each other, and then derive a new collection of non-intersecting cuboids having the same collective volume as the merging and reduction of the original `rebootStep` cuboids.

Later in this document we'll discuss the algoritms for identifying the new set of non-intersecting algorithms resulting from combining two cuboids.  But before we do that, I want to figure out the broader challenge of how to recursivly make sure that cuboids are continually broken apart until all cuboids are completely non-intesecting with each other.

# Preconditions

1. Ultimately, the algorithm has two operations, **augmentation** and **reduction**.  The two have different combinational effects, and so will be approached separately.
1. There are the following entities:
    * The list of initial cuboids, each with their associated actions, **augment** or **reduce**.
    * The target **remant** is empty.

# Approach

Here goes:

## Initialization

1. Skip to the first **augment** **rebootstep** (ignoring the previous **reduce** steps).[^1]
1. Since there are no cuboids in the **remnant**, place the first **augment** **rebootsteps**'s cuboid in it.  This is the first non-intersecting cuboid in the **remnant** since there are no other cubois in it.  Now that we have all of the non-intersecting cuboids for the first **rebootstep** cuboid, consider this **renmant** to be the *input* **remnant** in the following discussion.

## Do It Over and Over

Repeat the following process for the remaining cuboids in the **reboot steps** list:

For the current **rebootstep**

1. Remember the action, **augment** or **reduce**, specified in the **rebootstep**.

### If the action is an **augmentation**
Identify the cuboid in the current **rebootstep**.  This is always indentified as the *target* cuboid, in that the cuboids in the **remnant** will be repeatedly applied to the target to fracture it into sufficiently small pieces that the subset of the remaining pieces will be dumped into a new *output* **remant**.

Hence:

**Augment** each cuboid in the *source* **remnant** to each cuboid in the *target* **remnant**.  If there are not yet any cuboids in the *target* **remnant**, then do nothing and continue.

If the pair intersect, then do the following:

1. Indentify the *intersection* cuboid and the remaining *non-intersection* cuboids.
1. Add the *non-intersection* cuboids to the *target* **remnant**.
1. Discard the *non-intersection* cuboid since a previous cuboid in the *source* **remnant** already has its volume covered.

At the end of this process for each **rebootStep** cuboid:

1. The *target* remnant will have all of the non-intersecting cuboids needed to represent this **rebootStep** cuboid and the previous **rebootStep** cuboids.
1. Prepend the *target* **remnant** to the *source* **remnant**.[^2]
1. Reset the *target* **remant** to empty.

### Else the action is a **reduction**

**Reduce** the current **rebootstep**'s cuboid to each cuboid in the *source* **remnant**:

If the pair intersect, then:

1. Indentify the *intersection* cuboid and the remaining *non-intersection* cuboids.
1. Add the *non-intersection* cuboids to the *target* **remnant**.

At the end of this process for each **rebootstep** cuboid:

1. The *target* remnant will have all of the non-intersecting cuboids needed to represent this **rebootStep** cuboid and the previous **rebootStep** cuboids.
1. Do NOT prepend the *target* **remnant** to the *source* **remnant**, instead *replace it!*.[^3]

## And, we're done for this **rebootstep**

---

## Footnotes

[^1]: Since there's no purpose in applying a **reduce** to an empty **remnant**.

[^2]: This is because concatenating a long list to the end of a short list is faster than vice-versa.

[^3]: This realizes that a **reduce** action applied across the *souce* **remnant** removes everything that intersects with the **reduction**'s cuboid up to that point.
