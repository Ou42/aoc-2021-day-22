{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NamedFieldPuns #-}

module Day22 where

import Data.List (subsequences)
import qualified Data.Text as T

solvePuzzle :: String -> IO ()
solvePuzzle filePath = do
   inputText <- readFile filePath
   print (parseInputText inputText)

{- | Parse the exercise's input file contents to a list of reboot steps.
   |
   | Example:
   |
   | rebootSteps =
   |   parseInputFile "data/Day-22-Input-test.txt"
-}
parseInputText :: [Char] -> RebootSteps
parseInputText inputText =
   RebootSteps $ map (parseLine . T.pack) $ lines inputText

{-
   "on x=-20..26,y=-36..17,z=-47..7"
-}
parseLine :: T.Text -> RebootStep
parseLine line =
   mapTopTuple $ T.splitOn " " line
   where
      mapTopTuple :: [T.Text] -> RebootStep
      mapTopTuple (combine:rest) =
         RebootStep ( if combine == "on" then Sum else Difference
                    , let
                        xyz = T.splitOn "," $ head rest
                        [x,y,z] = map (toSegment . last . T.splitOn "=") xyz
                      in
                        Cuboid { x, y, z }
                    )

--    map (keepFstAltSnd . tuplify2 . words) lns

readInt :: T.Text -> Int
readInt s = read (T.unpack s) :: Int

toTuple :: [a] -> (a, a)
toTuple (x1:(x2:xs)) = (x1, x2)

toSegment :: T.Text -> Segment
toSegment pairStr = Segment $ toTuple $ map readInt $ T.splitOn ".." pairStr

-- import Utils (sequenceSteps) -- TODO (maybe)

{- | Sequence the reboot steps needed which, when executed, will generate
   | a list of non-intersecting cuboids.  Taking the sum of the volumes
   | of these cuboids will yield the answer to the Day 22 puzzle.
-}
-- Note: this isn't exactly right, but I can get ideas from it.
sequenceRebootSteps :: [RebootStep] -> [RebootStep]
sequenceRebootSteps rbs = concat $ subsequences rbs

{- | The actions parsed from the "reboot" file provided by the Day-22 exercise.
-}
newtype RebootSteps = RebootSteps [ RebootStep ] deriving (Show)

{- | The accumulation of applying
   | a `RebootStep` to all combinations of cuboid pairs
   | in the `RebootSteps`.
-}
newtype Remnants = Remnants [ Remnant ] deriving (Show)

{- | A `Cuboid` list of non-overlapping cuboids
   | generated by performing a `RebootStep`
   | upon 2 Cuboids.
-}
newtype Remnant = Remnant [ Cuboid Int Int Int ] deriving (Show)

{- Selects the function to implement the combining of the source and target cuboids
-}
data RebootOperator = Sum | Difference deriving (Eq, Show)

{- | The information parsed from each line in the Day-22 exercise input file
 -}
newtype RebootStep = RebootStep (RebootOperator,Cuboid Int Int Int) deriving (Eq, Show)

{- | Applies a `RebootStep` to a target `Cuboid`
   |
   | Properties
   |
   | 1. The `rebootStep` must always precede the `target`'s `RebootStep` in the `RebootSteps`' list.
-}
applyReboot :: RebootStep -> Cuboid Int Int Int -> Remnant
applyReboot rebootStep target = Remnant [] -- TODO

{- | return the first Cuboid and the remnant
   | of the second Cuboid.
   |
   | Properties
   |
   | 1. The combined volumes of the remnant == combined volumes of the 1st cuboid and the 2nd cuboid
   |    minus their intersection
-}
sum :: Cuboid Int Int Int -> Cuboid Int Int Int -> Remnant
sum source target = Remnant [] -- TODO

{- | return the remnant of subtracting the first
   | Cuboid from the second.
   |
   | Properties:
   |
   | 1. The combined volumes of the remnant == 2nd Cuboid's volume - the volume of the 2 cuboids' intersection
-}
difference :: Cuboid Int Int Int -> Cuboid Int Int Int -> Remnant
difference source target = Remnant [] -- TODO

data Cuboid x y z = Cuboid
  { x :: Segment
  , y :: Segment
  , z :: Segment
  } deriving (Eq, Show)

newtype Segment = Segment (Int, Int) deriving (Eq) -- fst <= snd

instance Show Segment where
   show (Segment s) = "(" ++ show (fst s) ++ "," ++ show (snd s) ++ ")"