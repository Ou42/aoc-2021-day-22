-- {-# LANGUAGE NamedFieldPuns #-}

module Remnant where

import Cuboid (Source(..), Target(..))
import Segment ( AxisResult(..)
               , AdjLeft(..)
               , AdjRight(..)
               , Overlap(..)
               , Segment(..)
               , SrcSeg(..)
               , TrgSeg(..)
               , compareSegments
               )

{- | A `Cuboid` list of non-intersecting cuboids
   | generated by recursively recursively performing a `RebootStep`
   | upon all the cuboids.
-}
type Remnant = [ Target ]

type AxisResults = [AxisResult]

mkAxisResults :: Source -> Target -> AxisResults
mkAxisResults (Source ss) (Target ts) = zipWith compareSegments ss ts

emptyRemnant :: Remnant
emptyRemnant = []

reduceRemnantUsingSource :: Remnant -> Source -> Remnant
reduceRemnantUsingSource previousRemnant source =
   foldl prepareReduce [] previousRemnant
   where
      prepareReduce :: Remnant -> Target -> Remnant
      prepareReduce targetRemnant target =
         reduce targetRemnant source target

{- | If there are any adjacent targets resulting from reducing
   | the current target from the source, then add them to the
   | remnant
   |
   | Properties:
   |
   | 1. The combined volumes of the remnant == 2nd Cuboid's volume - the volume of the 2 cuboids' intersection
-}
reduce :: Remnant -> Source -> Target -> Remnant
reduce inputRemnant source target =
   let
      axisResults = mkAxisResults source target
   in
   if NoOverlap `elem` axisResults then
      target : inputRemnant
   else
      let
         (_, outputRemnant, _) = foldl accumulateNonAdjacentTargets (target, inputRemnant, 0) axisResults
      in
      outputRemnant

{- | generate the adjacent target cuboids from the compare -}
accumulateNonAdjacentTargets :: (Target, Remnant, Int) -> AxisResult -> (Target, Remnant, Int)
accumulateNonAdjacentTargets (target, remnant, axisOffset) axisResult =
   case axisResult of
      Overlaps ->
         ( target, remnant, axisOffset + 1) -- Just bump axisOffset
      OverlapsLeft (Overlap overlap) (AdjRight adjRight) ->
         createCommon overlap ((createPiece target axisOffset adjRight) : remnant)
      OverlapsRight (AdjLeft adjLeft) (Overlap overlap) ->
         createCommon overlap ((createPiece target axisOffset adjLeft) : remnant)
      OverlappedByTarget (AdjLeft adjLeft) (Overlap overlap) (AdjRight adjRight) ->
         createCommon overlap ((createPiece target axisOffset adjRight) : ((createPiece target axisOffset adjLeft) : remnant))
   where
      createCommon :: TrgSeg -> Remnant -> (Target, Remnant, Int)
      createCommon overlap' newRemnant =
         ( createPiece target axisOffset overlap'
         , newRemnant
         , axisOffset + 1
         )

{- | Return a torn-off piece of the original cuboid -}
createPiece :: Target -> Int -> TrgSeg -> Target
createPiece (Target original) axisOffset segment =
   Target $ take axisOffset original <> [segment] <> drop (axisOffset+1) original
