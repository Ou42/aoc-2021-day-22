-- > > d <- readFile inputReal
-- > f10 = takeWhile (\(onOff,_,_,_) -> onOff == '+') $ solveBv2 d
-- > putStrLn $ unlines $ map show f10

-- :: Num a => (Char, [(a, a)], XYZ, LWH)
('+',[(-32,18),(-49,-2),(-43, 3)],XYZ (-32,-49,-43),LWH {xDim = 51, yDim = 48, zDim = 47})
('+',[(-15,35),(-31,16),( -9,43)],XYZ (-15,-31, -9),LWH {xDim = 51, yDim = 48, zDim = 53})
('+',[(-22,23),(  2,47),(-35,13)],XYZ (-22,  2,-35),LWH {xDim = 46, yDim = 46, zDim = 49})
('+',[(-45, 8),(-18,27),(-34,17)],XYZ (-45,-18,-34),LWH {xDim = 54, yDim = 46, zDim = 52})
('+',[(-15,31),(-41, 9),(-35,19)],XYZ (-15,-41,-35),LWH {xDim = 47, yDim = 51, zDim = 55})
('+',[(-28,21),(  0,46),(-27,27)],XYZ (-28,  0,-27),LWH {xDim = 50, yDim = 47, zDim = 55})
('+',[(  3,49),(-29,15),(-45, 4)],XYZ (  3,-29,-45),LWH {xDim = 47, yDim = 45, zDim = 50})
('+',[(-41, 8),(-29,22),(-48,-2)],XYZ (-41,-29,-48),LWH {xDim = 50, yDim = 52, zDim = 47})
('+',[(-22,27),(-46,-2),(-12,37)],XYZ (-22,-46,-12),LWH {xDim = 50, yDim = 45, zDim = 50})
('+',[(-19,25),( -5,41),(-49, 0)],XYZ (-19, -5,-49),LWH {xDim = 45, yDim = 47, zDim = 50})

-- Scott likes this version of the above (in which XYZ to the left is no longer used):
(`+`,[(-32,18),(-49,-2),(-43, 3)] -- notice '+' has been turned into an infix operator
(`+`,[(-15,35),(-31,16),( -9,43)]
(`+`,[(-22,23),(  2,47),(-35,13)]
(`+`,[(-45, 8),(-18,27),(-34,17)]
(`+`,[(-15,31),(-41, 9),(-35,19)]
(`+`,[(-28,21),(  0,46),(-27,27)]
(`+`,[(  3,49),(-29,15),(-45, 4)]
(`+`,[(-41, 8),(-29,22),(-48,-2)]
(`+`,[(-22,27),(-46,-2),(-12,37)]
(`+`,[(-19,25),( -5,41),(-49, 0)]

> putStrLn $ unlines $ map show $ mySort f10

('+',[(-45, 8),(-18,27),(-34,17)],XYZ (-45,-18,-34),LWH {xDim = 54, yDim = 46, zDim = 52})
('+',[(-41, 8),(-29,22),(-48,-2)],XYZ (-41,-29,-48),LWH {xDim = 50, yDim = 52, zDim = 47})
('+',[(-32,18),(-49,-2),(-43, 3)],XYZ (-32,-49,-43),LWH {xDim = 51, yDim = 48, zDim = 47})
('+',[(-28,21),(  0,46),(-27,27)],XYZ (-28,  0,-27),LWH {xDim = 50, yDim = 47, zDim = 55})
('+',[(-22,23),(  2,47),(-35,13)],XYZ (-22,  2,-35),LWH {xDim = 46, yDim = 46, zDim = 49})
('+',[(-22,27),(-46,-2),(-12,37)],XYZ (-22,-46,-12),LWH {xDim = 50, yDim = 45, zDim = 50})
('+',[(-19,25),( -5,41),(-49, 0)],XYZ (-19, -5,-49),LWH {xDim = 45, yDim = 47, zDim = 50})
('+',[(-15,35),(-31,16),( -9,43)],XYZ (-15,-31, -9),LWH {xDim = 51, yDim = 48, zDim = 53})
('+',[(-15,31),(-41, 9),(-35,19)],XYZ (-15,-41,-35),LWH {xDim = 47, yDim = 51, zDim = 55})
('+',[(  3,49),(-29,15),(-45, 4)],XYZ (  3,-29,-45),LWH {xDim = 47, yDim = 45, zDim = 50})

==== thinking ====

('+',[(-45, 8),(-18,27),(-34,17)],XYZ (-45,-18,-34),LWH {xDim = 54, yDim = 46, zDim = 52})
('+',[(-41, 8),(-29,22),(-48,-2)],XYZ (-41,-29,-48),LWH {xDim = 50, yDim = 52, zDim = 47})

it's sorted on minX's, start w/ X's take 2 objs ...
  first, a visual, there are 5? possible scenarios:
            (rem, it's sorted on minX)
  (1) obj 1's X's ----          no overlap
      obj 2's X's      ----
  (2) obj 1's X's ----          obj 1 + 2 overlap objs + obj 2
      obj 2's X's   ----
  (3) obj 1's X's ----          obj 1 + 2 overlap objs
      obj 2's X's   --
  (4) obj 1's X's ----          obj 1 + 2 overlap objs + obj 1
      obj 2's X's  --
  (5) obj 1's X's ----          clones == total overlap
      obj 2's X's ----

+ store overlap *TWICE* move on to Y's then move on to Z's
(minX, maxX) --> obj1 = (-45,8) & obj2 = (-41,8)
== new obj (-45,-42) + obj1's overlap (-41,8) + obj2's overlap (-41,8)
   ... when there's an overlap in Z's keep ONE copy, discard 2nd.

(minX, maxX) --> obj1 = (-41,8) & obj2 = (-32,18)
== new obj (-41,-33) + overlap (-32,18)

[-45 .. (-41)-1] == [-45]

> break (== (5)) [5..10]
([],[5,6,7,8,9,10])
> break (== (7)) [5..10]
([5,6],[7,8,9,10])
> break (== (12)) [5..10]
([5,6,7,8,9,10],[])

aka - if it's sorted, then cu1's val is equal or greater than cu0's
        ... IOW it can never be less than!

> a
('+',[(-49,1),(-3,46),(-24,28)])
> b
('+',[(-46,7),(-6,46),(-50,-1)])
> db $ union a b
('+',[(-49,-47),(-3,46),(-24,28)])
('+',[(-46,1),(-3,46),(-24,28)])
('+',[(-46,7),(-6,46),(-50,-1)])

> a = ('+',[(-49,1),(-3,46),(-24,28)])
> b = ('+',[(-46,7),(-6,46),(-50,-1)])
> union a b
[[(-49,-47),(-3,46),(-24,28)],[(-46,1),(-6,-4),(-50,-1)],[(-46,1),(-3,46),(-50,-25)],[(4200,2)]]
> db $ union a b
[(-49,-47),(-3,46),(-24,28)]
[(-46,1),(-6,-4),(-50,-1)]
[(-46,1),(-3,46),(-50,-25)]
[(4200,2)]

> u = init $ union a b
> db $ map (appendXYZLWH . ((,) '+')) u
('+',[(-49,-47),(-3,46),(-24,28)],XYZ (-49,-3,-24),LWH {xDim = 3, yDim = 50, zDim = 53})
('+',[(-46,1),(-6,-4),(-50,-1)],XYZ (-46,-6,-50),LWH {xDim = 48, yDim = 3, zDim = 50})
('+',[(-46,1),(-3,46),(-50,-25)],XYZ (-46,-3,-50),LWH {xDim = 48, yDim = 50, zDim = 26})

> appendXYZLWH a
('+',[(-49,1),(-3,46),(-24,28)],XYZ (-49,-3,-24),LWH {xDim = 51, yDim = 50, zDim = 53})
> appendXYZLWH b
('+',[(-46,7),(-6,46),(-50,-1)],XYZ (-46,-6,-50),LWH {xDim = 54, yDim = 53, zDim = 50})

-- ====================================================
> fmap (break (== (7))) $ break (== (-46)) [-49..1]
([-49,-48,-47],([-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1],[]))
-- ====================================================

> fmap (break (== (1))) $ break (== (-49)) [-46..7]
([-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7],([],[]))

import Control.Monad  (join)
import Data.Bifunctor (bimap)

join bimap (2*) (1,2)

-- or --

mapTuple :: (a -> b) -> (a, a) -> (b, b)
mapTuple f (a1, a2) = (f a1, f a2)

-- but... is any of this necessary?!
+++++++++++++++++++++++++++++++++
+ just need 3 goups, LT, EQ, GT +
+++++++++++++++++++++++++++++++++
... where the EQ group is the overlap!

-- myBreak takes min/max of 2 cuboids and breaks apart the FIRST cuboid only!
-- + this was my confusion! I previously was trying to get the whole range
--   of the 2 cuboids.
-- + the returned list is [LT range, EQ range, GT range]
--   ... so, keep the LT and GT and drop the EQ and append cuboid 2!
-- + "dropping the EQ" **means** recursively checking for dupes in all XYZ ranges!
--   ... IOW do NOT drop EQ when in X or Y, ONLY drop EQ when in Z
> myBreak (-49,1) (-46,7)
[[-49,-47],[-46,1],[]]
> myBreak (-46,7) (-49,1)
[[],[-46,1],[2,7]]

> myBreak (1,2) (3,4)
[[1,2],[],[]]
> myBreak (5,6) (3,4)
[[],[],[5,6]]
> myBreak (3,4) (3,4)
[[],[3,4],[]]
> myBreak (3,4) (2,5)
[[],[3,4],[]]
>

> a
('+',[(-49,1),(-3,46),(-24,28)])
> b
('+',[(-46,7),(-6,46),(-50,-1)])
> foldr (\(r0,r1) accu -> (myBreak r0 r1):accu) [] $ zip aRng bRng
[ [Just (-49,-47),Just (-46,1),Nothing] -- LT
, [Nothing,Just (-3,46),Nothing]        -- EQ
, [Nothing,Just (-24,-1),Just (0,28)] ] -- GT

so, if this is working...
  non-overlap in X: [ (-49,-47), (-3,46), (-24,28) ] ==  3x50x53 ==  7950
  non-overlap in Y: Nothing
  non-overlap in Z: [ (-46,  1), (-3,46), (  0,28) ] == 48x50x29 == 69600
  overlap is:       [ (-46,  1), (-3,46), (-24,-1) ] == 48x50x24 == 57600
                                                                   ======
                                                                   135150
a = ('+',[(-49,1),(-3,46),(-24,28)]) = 51x50x53 == 135150 YASSS!!

b = ('+',[(-46,7),(-6,46),(-50,-1)]) = 54x53x50 == 143100
                                                  =======
                                                   278250
                                                 -  57600 (overlap)
                                                  =======
                                                   220650 hmmm

        > after a bunch of editing in Blender... YES! 220.65 cm^3

        > ... probs w/ "non manifold edges" & "bad contig. edges"
        > ... the later is fixed w/ Sel All ("a") then:
        >       Mesh->Normals->Recalculate Inside
        > ... the former, "non manifold" is currently work:
        >       I created new edges by selecting points and
        >       "f" create new "edge".
        > ... not sure if it is splitting existing faces!

        > ... & shouldn't there be a tool to do this?!

        > ... or should I just import unit cubes at each vert?!

so, append LT & GT to a List, then carry over EQ, using its values
to populate future ranges.

To Blender!
a = ('+',[(-49,1),(-3,46),(-24,28)])



v -49 -3 -24
v -49 -3 28
v v -49 46 -24
v -49 46 28
v 1 -3 -24
v 1 -3 28
v 1 46 -24
v 1 46 28

f 1 2 3 4
f 5 6 7 8

> db $ difference a b
('+',[(-45,-42),(-18,27),(-34,17)])
('+',[(-41,8),(23,27),(-34,17)])
('+',[(-41,8),(-18,22),(-1,17)])

===

intersects if OFF!
a = ('+',[(-45,-42),(-18,27),(-34,17)])
b = ('+',[(-41,8),(23,27),(-34,17)])
intersects a b == False! -- it was saying True. fixed?!


gs = solveBv2 d -- when it returned nGrp : goDiff nGrp
> length (gs !! 0) == length ( nub ( gs !! 0 ))
True
> length (gs !! 1) == length ( nub ( gs !! 1 ))
True
> length (gs !! 2) == length ( nub ( gs !! 2 ))
True
> length (gs !! 3) == length ( nub ( gs !! 3 ))
True
> length (gs !! 4) == length ( nub ( gs !! 4 ))
True

> db $ head gs
('+',[(-45,8),(-18,27),(-34,17)])
('+',[(-41,8),(-29,22),(-48,-2)])
('+',[(-32,18),(-49,-2),(-43,3)])
('+',[(-28,21),(0,46),(-27,27)])
('+',[(-22,23),(2,47),(-35,13)])
('+',[(-22,27),(-46,-2),(-12,37)])
('+',[(-19,25),(-5,41),(-49,0)])
('+',[(-15,35),(-31,16),(-9,43)])
('+',[(-15,31),(-41,9),(-35,19)])
('+',[(3,49),(-29,15),(-45,4)])

> db $ gs !! 1
('+',[(-45,-42),(-18,27),(-34,17)])
('+',[(-41,8),(23,27),(-34,17)])
('+',[(-41,8),(-18,22),(-1,17)])
('+',[(-41,-33),(-29,22),(-48,-2)])
('+',[(-32,8),(-1,22),(-48,-2)])
('+',[(-32,8),(-29,-2),(-48,-44)])
('+',[(-32,18),(-49,-2),(-43,3)])
('+',[(-28,-23),(0,46),(-27,27)])
('+',[(-22,21),(0,1),(-27,27)])
('+',[(-22,21),(2,46),(14,27)])
('+',[(-22,23),(2,47),(-35,13)])
('+',[(-22,27),(-46,-2),(-12,37)])
('+',[(-19,-16),(-5,41),(-49,0)])
('+',[(-15,25),(17,41),(-49,0)])
('+',[(-15,25),(-5,16),(-49,-10)])
('+',[(32,35),(-31,16),(-9,43)])
('+',[(-15,31),(10,16),(-9,43)])
('+',[(-15,31),(-31,9),(20,43)])
('+',[(-15,2),(-41,9),(-35,19)])
('+',[(3,31),(-41,-30),(-35,19)])
('+',[(3,31),(-29,9),(5,19)])

> db diff
[('+',[(-45,-42),(-18,27),(-34,17)])
,('+',[(-41,8),(23,27),(-34,17)])
,('+',[(-41,8),(-18,22),(-1,17)])]

[('+',[(-41,-33),(-29,22),(-48,-2)]),('+',[(-32,8),(-1,22),(-48,-2)]),('+',[(-32,8),(-29,-2),(-48,-44)])]
[('+',[(-32,18),(-49,-2),(-43,3)])]
[('+',[(-28,-23),(0,46),(-27,27)]),('+',[(-22,21),(0,1),(-27,27)]),('+',[(-22,21),(2,46),(14,27)])]
[('+',[(-22,23),(2,47),(-35,13)])]
[('+',[(-22,27),(-46,-2),(-12,37)])]
[('+',[(-19,-16),(-5,41),(-49,0)]),('+',[(-15,25),(17,41),(-49,0)]),('+',[(-15,25),(-5,16),(-49,-10)])]
[('+',[(32,35),(-31,16),(-9,43)]),('+',[(-15,31),(10,16),(-9,43)]),('+',[(-15,31),(-31,9),(20,43)])]

[('+',[(-15,2),(-41,9),(-35,19)])
,('+',[(3,31),(-41,-30),(-35,19)])
,('+',[(3,31),(-29,9),(5,19)])]

> d <- readFile inputReal
> sb2 = solveBv2 d
> db sb2
('+',[(-45,-42),(-18,27),(-34,17)])
('+',[(-41,8),(23,27),(-34,17)])
('+',[(-41,8),(-18,22),(-1,17)])
('+',[(-41,-33),(-29,22),(-48,-2)])
('+',[(-32,8),(-1,22),(-48,-2)])
('+',[(-32,8),(-29,-2),(-48,-44)])
('+',[(-32,18),(-49,-2),(-43,3)])
('+',[(-28,-23),(0,46),(-27,27)])
('+',[(-22,21),(0,1),(-27,27)])
('+',[(-22,21),(2,46),(14,27)])
('+',[(-22,23),(2,47),(-35,13)])
('+',[(-22,27),(-46,-2),(-12,37)])
('+',[(-19,-16),(-5,41),(-49,0)])
('+',[(-15,25),(17,41),(-49,0)])
('+',[(-15,25),(-5,16),(-49,-10)])
('+',[(32,35),(-31,16),(-9,43)])
('+',[(-15,31),(10,16),(-9,43)])
('+',[(-15,31),(-31,9),(20,43)])
('+',[(-15,2),(-41,9),(-35,19)])
('+',[(3,31),(-41,-30),(-35,19)])
('+',[(3,31),(-29,9),(5,19)])
('+',[(3,49),(-29,15),(-45,4)])

> db sb2
[('+',[(-45,8),(-18,27),(-34,17)]),('+',[(-41,8),(-29,22),(-48,-2)]),('+',[(-32,18),(-49,-2),(-43,3)]),('+',[(-28,21),(0,46),(-27,27)]),('+',[(-22,23),(2,47),(-35,13)]),('+',[(-22,27),(-46,-2),(-12,37)]),('+',[(-19,25),(-5,41),(-49,0)]),('+',[(-15,35),(-31,16),(-9,43)]),('+',[(-15,31),(-41,9),(-35,19)]),('+',[(3,49),(-29,15),(-45,4)])]
[('+',[(-45,-42),(-18,27),(-34,17)]),('+',[(-41,8),(23,27),(-34,17)]),('+',[(-41,8),(-18,22),(-1,17)]),('+',[(-41,-33),(-29,22),(-48,-2)]),('+',[(-32,8),(-1,22),(-48,-2)]),('+',[(-32,8),(-29,-2),(-48,-44)]),('+',[(-32,18),(-49,-2),(-43,3)]),('+',[(-28,-23),(0,46),(-27,27)]),('+',[(-22,21),(0,1),(-27,27)]),('+',[(-22,21),(2,46),(14,27)]),('+',[(-22,23),(2,47),(-35,13)]),('+',[(-22,27),(-46,-2),(-12,37)]),('+',[(-19,-16),(-5,41),(-49,0)]),('+',[(-15,25),(17,41),(-49,0)]),('+',[(-15,25),(-5,16),(-49,-10)]),('+',[(32,35),(-31,16),(-9,43)]),('+',[(-15,31),(10,16),(-9,43)]),('+',[(-15,31),(-31,9),(20,43)]),('+',[(-15,2),(-41,9),(-35,19)]),('+',[(3,31),(-41,-30),(-35,19)]),('+',[(3,31),(-29,9),(5,19)]),('+',[(3,49),(-29,15),(-45,4)])]
[('+',[(-45,-42),(-18,27),(-34,17)]),('+',[(-41,8),(23,27),(-34,17)]),('+',[(-41,8),(-18,22),(-1,17)]),('+',[(-41,-33),(-29,22),(-48,-2)]),('+',[(-32,8),(-1,22),(-48,-2)]),('+',[(-32,8),(-29,-2),(-48,-44)]),('+',[(-32,18),(-49,-2),(-43,3)]),('+',[(-28,-23),(0,46),(-27,27)]),('+',[(-22,21),(0,1),(-27,27)]),('+',[(-22,21),(2,46),(14,27)]),('+',[(-22,23),(2,47),(-35,13)]),('+',[(-22,27),(-46,-2),(-12,37)]),('+',[(-19,-16),(-5,41),(-49,0)]),('+',[(-15,25),(17,41),(-49,0)]),('+',[(-15,25),(-5,16),(-49,-10)]),('+',[(32,35),(-31,16),(-9,43)]),('+',[(-15,31),(10,16),(-9,43)]),('+',[(-15,31),(-31,9),(20,43)]),('+',[(-15,2),(-41,9),(-35,19)]),('+',[(3,31),(-41,-30),(-35,19)]),('+',[(3,31),(-29,9),(5,19)]),('+',[(3,49),(-29,15),(-45,4)])]

> iFree (sb2 !! 1)
True
> iFree (drop 1 $ sb2 !! 1)
False
> culprits (drop 1 $ sb2 !! 1)
[('+',[(-22,21),(2,46),(14,27)]),('+',[(-22,23),(2,47),(-35,13)]),('+',[(-15,25),(17,41),(-49,0)])]


> db [a,b]
('+',[(-32,18),(-49,-2),(-43,3)])
('+',[(-15,35),(-31,16),(-9,43)])

> db $ difference a b
('+',[(-32,-16),(-49,-2),(-43,3)])
('+',[(-15,18),(-49,-32),(-43,3)])
('+',[(-15,18),(-31,-2),(-43,-10)])

> db diff
('+',[(-32,-16),(-49,-2),(-43,3)])
('+',[(-15,18),(-49,-32),(-43,3)])
('+',[(-15,18),(-31,-2),(-43,-10)])

======
Excepion tail ... then head ... newDiff...

psA = ('+',[(-32,-16),(-18,-2),(-43,-35)])
psRest = [('+',[(-15,18),(-49,-32),(-43,3)]),('+',[(-15,18),(-31,-2),(-43,-10)]),('+',[(-15,35),(-31,16),(-9,43)]),('+',[(-22,23),(2,47),(-35,13)]),('+',[(-45,8),(-18,27),(-34,17)]),('+',[(-15,31),(-41,9),(-35,19)]),('+',[(-28,21),(0,46),(-27,27)]),('+',[(3,49),(-29,15),(-45,4)]),('+',[(-41,8),(-29,22),(-48,-2)]),('+',[(-22,27),(-46,-2),(-12,37)]),('+',[(-19,25),(-5,41),(-49,0)])]


> d <- readFile i3
> as = allSteps d
> ds as
('+',[(-32,18),(-49,-2),(-43,3)])
('+',[(-15,35),(-31,16),(-9,43)])
('+',[(-22,23),(2,47),(-35,13)])
('+',[(-45,8),(-18,27),(-34,17)])
('+',[(-15,31),(-41,9),(-35,19)])
('+',[(-28,21),(0,46),(-27,27)])
('+',[(3,49),(-29,15),(-45,4)])
('+',[(-41,8),(-29,22),(-48,-2)])
('+',[(-22,27),(-46,-2),(-12,37)])
('+',[(-19,25),(-5,41),(-49,0)])

> d <- readFile i3
> solveA d
547647
> vol $ map snd $ newDiffGrps $ allSteps d
552507

=======

> d <- readFile i3
> as = allSteps d
> putStrLn $ unlines $ map (show . lst2Tup2Lst3 . snd) as
[[-32,-49,-43],[-32,-49,3],[-32,-2,-43],[-32,-2,3],[18,-49,-43],[18,-49,3],[18,-2,-43],[18,-2,3]]
[[-15,-31,-9],[-15,-31,43],[-15,16,-9],[-15,16,43],[35,-31,-9],[35,-31,43],[35,16,-9],[35,16,43]]
[[-22,2,-35],[-22,2,13],[-22,47,-35],[-22,47,13],[23,2,-35],[23,2,13],[23,47,-35],[23,47,13]]
[[-45,-18,-34],[-45,-18,17],[-45,27,-34],[-45,27,17],[8,-18,-34],[8,-18,17],[8,27,-34],[8,27,17]]
[[-15,-41,-35],[-15,-41,19],[-15,9,-35],[-15,9,19],[31,-41,-35],[31,-41,19],[31,9,-35],[31,9,19]]
[[-28,0,-27],[-28,0,27],[-28,46,-27],[-28,46,27],[21,0,-27],[21,0,27],[21,46,-27],[21,46,27]]
[[3,-29,-45],[3,-29,4],[3,15,-45],[3,15,4],[49,-29,-45],[49,-29,4],[49,15,-45],[49,15,4]]
[[-41,-29,-48],[-41,-29,-2],[-41,22,-48],[-41,22,-2],[8,-29,-48],[8,-29,-2],[8,22,-48],[8,22,-2]]
[[-22,-46,-12],[-22,-46,37],[-22,-2,-12],[-22,-2,37],[27,-46,-12],[27,-46,37],[27,-2,-12],[27,-2,37]]
[[-19,-5,-49],[-19,-5,0],[-19,41,-49],[-19,41,0],[25,-5,-49],[25,-5,0],[25,41,-49],[25,41,0]]