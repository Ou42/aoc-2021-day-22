-- {-# LANGUAGE NamedFieldPuns #-}

module Remnant where

import Cuboid (Source(..), Target(..))
import Segment ( AxisResult(..)
               , AdjLeft(..)
               , AdjRight(..)
               , Overlap(..)
               , Segment(..)
               , SrcSeg(..)
               , TrgSeg(..)
               , compareSegments
               )

{- | A `Cuboid` list of non-intersecting cuboids
   | generated by recursively recursively performing a `RebootStep`
   | upon all the cuboids.
-}
-- ISSUE: 'Remnant' is not good enough name.  Should be called something
--        akin to 'NonIntersectingCuboidsAccumulatingRepository'
--        i.e. the acronym 'nicar'. Or I'd go with the more active
--        'RepositoryAccumulatingNonIntersectingCuboids' or 'ranic' which
--        is Polish for hurt, injure, lacerate, or wound.  Maintainers Beware!
type Remnant = [ Target ]

type AxisResults = [AxisResult]

mkAxisResults :: Source -> Target -> AxisResults
mkAxisResults (Source ss) (Target ts) = zipWith compareSegments ss ts

emptyRemnant :: Remnant
emptyRemnant = []

reduceRemnantUsingSource :: Remnant -> Source -> Remnant
reduceRemnantUsingSource previousRemnant source =
   foldl prepareReduce emptyRemnant previousRemnant -- NOTE: each Source starts a new remnant
   where
      prepareReduce :: Remnant -> Target -> Remnant
      prepareReduce targetRemnant target =
         reduce targetRemnant source target

{- | If there are any adjacent targets resulting from reducing
   | the current target from the source, then add them to the
   | remnant
   |
   | Properties:
   |
   | 1. The combined volumes of the remnant == 2nd Cuboid's volume - the volume of the 2 cuboids' intersection
-}
-- ISSUE: Plea for better name; 'reduce' is too "wishy-washy".
--        Let's change it to "decompose"; we are decomposing to separate
--        the intersection cuboids into those that will be used as what
--        we've been calling 'overlay's vs those that are going to go into
--        the remnant.
reduce :: Remnant -> Source -> Target -> Remnant
reduce incomingRemnant source target =
   let
      axisResults = mkAxisResults source target

      -- ISSUE: This functionality duplicated in CalculatePartA
      noOverlap   = (Nothing, [])
   in
   -- ISSUE: From here up the end of the function is a hack
   -- that was hard to write and will be hard to understand.
   -- Suggested change in Segment that will make the needed
   -- changes obvious.
   if noOverlap `elem` axisResults then
      target : incomingRemnant
   else
      let
         (_, outgoingRemnant, _) = foldl accumulateRemnantCandidates (target, incomingRemnant, 0) axisResults
      in
      outgoingRemnant

{- | Accumulate remnant candidates while shrinking target for next axis resize calculation -}
accumulateRemnantCandidates :: (Target, Remnant, Int) -> AxisResult -> (Target, Remnant, Int)
accumulateRemnantCandidates (target, remnant, axisOffset) axisResult@(Just overlap, remainder) =
   createCommon overlap $ foldl prependPiece remnant remainder
   where
      createCommon :: TrgSeg -> Remnant -> (Target, Remnant, Int)
      createCommon overlap' newRemnant =
         -- ISSUE: createPiece here redundently recreates the
         -- cuboid already defined by 'target' above when it
         -- doesn't need to.
         ( createPiece overlap'
         , newRemnant
         , axisOffset + 1
         )

      {- | Return a torn-off piece of the original cuboid -}
      prependPiece :: Remnant -> TrgSeg -> Remnant
      prependPiece remnant' segment =
         (createPiece segment) : remnant'

      -- ISSUE: Duplicated in CalculatePartA
      createPiece :: TrgSeg -> Target
      createPiece segment =
         let
            Target incoming = target
         in
            (Target $ take axisOffset incoming <> [segment] <> drop (axisOffset+1) incoming)